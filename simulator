import time
import uuid
import math
import random
import collections

# Importing your logic (Assuming these are in the same directory or defined above)
from gossip_node import GossipNode
from message_builder import MessageBuilder

class SimulatedNode(GossipNode):
    """
    Extends your GossipNode to bypass actual UDP sockets 
    and communicate directly with other instances in memory.
    """
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.simulator = None
        self.messages_sent_count = 0

    def log(self, message):
        # Silencing standard logs to keep the console clean for results
        pass

    def send_udp(self, target_addr, message_dict):
        """Mocks the UDP send by passing the message directly to the target node."""
        self.messages_sent_count += 1
        if self.simulator:
            self.simulator.deliver_message(target_addr, message_dict)

class GossipNetworkSimulator:
    def __init__(self, n_nodes, fanout, ttl, seed=42):
        self.n_nodes = n_nodes
        self.nodes = {}
        self.total_messages = 0
        self.target_count = math.ceil(n_nodes * 0.95)
        
        # Initialize nodes using your GossipNode parameters
        for i in range(n_nodes):
            port = 8000 + i
            node = SimulatedNode(
                port=port,
                bootstrap=None,
                fanout=fanout,
                ttl=ttl,
                peer_limit=n_nodes,
                ping_interval=10,
                peer_timeout=60,
                seed=seed
            )
            node.simulator = self
            self.nodes[node.self_addr] = node

        # Build a random connected topology so nodes know each other
        random.seed(seed)
        addrs = list(self.nodes.keys())
        for addr, node in self.nodes.items():
            # Give each node some initial neighbors so they have someone to gossip to
            neighbors = random.sample([a for a in addrs if a != addr], min(n_nodes-1, fanout * 2))
            for n_addr in neighbors:
                node.peers[n_addr] = {"node_id": str(uuid.uuid4()), "last_seen": time.time()}

    def deliver_message(self, target_addr, msg):
        self.total_messages += 1
        if target_addr in self.nodes:
            # Use your exact handle_message logic
            self.nodes[target_addr].handle_message(msg)

    def run(self, message_text="Simulated Gossip Payload"):
        # Select the entry point node
        start_node_addr = list(self.nodes.keys())[0]
        start_node = self.nodes[start_node_addr]
        
        # Build the GOSSIP message using your MessageBuilder
        payload = {
            "topic": "sim",
            "data": message_text,
            "origin_id": start_node.node_id,
            "origin_timestamp_ms": int(time.time() * 1000)
        }
        gossip_msg = MessageBuilder.build('GOSSIP', start_node.node_id, start_node.self_addr, payload, start_node.ttl)
        msg_id = gossip_msg['msg_id']

        # Start the infection
        start_node.seen_messages.add(msg_id)
        start_node.gossip_reception_times[msg_id] = 0 # Start time
        start_node.forward_gossip(gossip_msg, start_node.ttl)

        return self.analyze_results(msg_id)

    def analyze_results(self, msg_id):
        # Collect all reception times from your nodes' internal state
        receptions = []
        for node in self.nodes.values():
            if msg_id in node.gossip_reception_times:
                receptions.append(node.gossip_reception_times[msg_id])
        
        receptions.sort()
        
        reached_95 = len(receptions) >= self.target_count
        time_to_95 = 0
        if reached_95:
            # In this mocked sync version, we look at the "hops" or delivery sequence
            # Since we don't have real network delay, the 'count' is our proxy for time
            time_to_95 = len(set(receptions)) # Distinct propagation waves

        return {
            "total_nodes": self.n_nodes,
            "reached_count": len(receptions),
            "reached_95_percent": reached_95,
            "total_messages_sent": self.total_messages,
            "propagation_waves": time_to_95
        }

# --- Main Simulation Execution ---
if __name__ == "__main__":
    # Configuration
    N_NODES = 100
    FANOUT = 3
    TTL = 10
    SEED = 42

    print(f"Starting simulation with {N_NODES} nodes (Fanout: {FANOUT}, TTL: {TTL})...")
    
    sim = GossipNetworkSimulator(N_NODES, FANOUT, TTL, SEED)
    stats = sim.run("Hello World")

    print("\n" + "="*30)
    print("SIMULATION RESULTS")
    print("="*30)
    print(f"Nodes Reached:      {stats['reached_count']}/{stats['total_nodes']}")
    print(f"95% Goal Met:       {stats['reached_95_percent']}")
    print(f"Total UDP Messages: {stats['total_messages_sent']}")
    print(f"Propagation Waves:  {stats['propagation_waves']} (Steps to reach final node)")
    print("="*30)